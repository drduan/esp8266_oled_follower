
/*
 * 使用ESP8266-01/12模块通过I2C驱动OLED SSD1306模块
 * 注意:
 *    ESP8266-12  需要设定D1, D2端口来驱动, 也就是GPIO5, GPIO4
 *    Wire.begin(5, 4);
 *    ESP8266-01  需要使用Rx和Tx端口驱动, 也就是GPIO3, GPIO1
 *    
 *    Wire需要设定 d1 d2 端口来驱动 也就是gpi05 gpi04 
 *    
 *    Wire需要设定I2C时钟频率, 最大700KHz(相对160MHz模式下的CPU) 
 *    如果是80MHz建议设置400KHz, 不过经测试, 直接设置700KHz也是可以的
 *    Wire.setClock(700000);
 */
#include <Arduino.h>
#include <ArduinoJson.h>

#include <SPI.h>
#include <Wire.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>

#include <ESP8266WiFi.h>
#include <ESP8266WiFiMulti.h>
#include <ESP8266HTTPClient.h>

//汉字"UP： 粉丝：",16*16
static unsigned char LOGO_CH[12][128] = {
  
{0x00,0x00,0x00,0xE7,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x42,0x3C,0x00,0x00},/*"U",0*/

{0x00,0x00,0x00,0xFC,0x42,0x42,0x42,0x42,0x7C,0x40,0x40,0x40,0x40,0xE0,0x00,0x00},/*"P",1*/

{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x00,0x00},/*"：",2*/

{0x10,0x10,0x10,0x50,0x94,0x50,0x54,0x50,0x58,0x88,0x10,0x88,0xFD,0x04,0x32,0xFA,
0x38,0x48,0x54,0x48,0x54,0x48,0x90,0x48,0x10,0x88,0x10,0x88,0x11,0x28,0x12,0x10},/*"粉",3*/

{0x08,0x10,0x08,0x10,0x10,0x20,0x10,0x20,0x22,0x44,0x42,0x84,0x7C,0xF8,0x04,0x08,
0x08,0x10,0x10,0x20,0x20,0x40,0x7E,0xFC,0x00,0x00,0x00,0x00,0xFF,0xFE,0x00,0x00},/*"丝",4*/

{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x30,0x00,0x30,0x00,0x00,0x00,0x00,0x00},/*"：",5*/


 {0x06,0x00,0x38,0xF8,0x20,0x88,0x20,0x88,0x20,0x88,0x3C,0x86,0x21,0x00,0x20,0x00,
0x3D,0xFC,0x20,0x84,0x20,0x88,0x2C,0x50,0xF0,0x20,0x20,0x50,0x20,0x88,0x23,0x06},/*"段",6*/
{0x20,0x00,0x20,0xF8,0x20,0x88,0x20,0x88,0xFC,0x88,0x24,0xF8,0x24,0x88,0x24,0x88,
0x24,0x88,0x24,0x88,0x24,0xF8,0x24,0x8A,0x24,0x02,0x44,0x02,0x43,0xFE,0x80,0x00},/*"旭",7*/
{0x02,0x00,0x02,0x00,0x02,0x00,0x7F,0xFC,0x04,0x00,0x09,0x00,0x11,0x00,0x21,0x00,
0x3F,0xF8,0x01,0x00,0x09,0x20,0x11,0x10,0x21,0x08,0x41,0x04,0x05,0x00,0x02,0x00},/*"东",8*/

/* (16 X 16 , 宋体 )*/



};

//滑稽表情 128*64
static unsigned char LOGO_HJ[] ={
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x00,0x00,0x00,0x00,
0x00,0x00,0x07,0xFF,0xFF,0xC0,0x00,0x00,0x00,0x03,0x00,0x18,0x00,0x00,0x00,0x00,
0x00,0x00,0x0C,0x7F,0xD0,0x30,0x00,0x00,0x00,0x01,0xC0,0x00,0x03,0x80,0x00,0x00,
0x00,0x7C,0x0F,0xC0,0x60,0x10,0x00,0x00,0x00,0x00,0x00,0xFE,0x0F,0x00,0x00,0x00,
0x01,0xC7,0xFC,0x00,0x30,0x10,0x00,0x00,0x00,0x00,0x07,0xFF,0x80,0x00,0x00,0x00,
0x01,0x80,0x00,0x00,0x70,0x1C,0x00,0x00,0x00,0x00,0x0F,0xFF,0xE0,0x00,0x00,0x00,
0x00,0x80,0x00,0x07,0xFF,0xFC,0x00,0x00,0x00,0x00,0x1F,0xFF,0xE3,0xF0,0x00,0x00,
0x00,0xFF,0xFF,0xFE,0x0C,0x00,0x00,0x00,0x00,0x1F,0xC7,0xFF,0xE1,0xF0,0x00,0x00,
0x00,0x00,0x00,0x00,0x7F,0x00,0x00,0x00,0x00,0x00,0x03,0xFF,0xE0,0x00,0x00,0x00,
0x00,0x00,0x00,0x01,0xC0,0xE0,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x0F,0x00,0x3C,0x00,0x00,0x3F,0x00,0x04,0x00,0x07,0x00,0x00,0x00,
0x00,0x00,0x00,0x38,0x00,0x06,0x00,0x00,0xC1,0x80,0x1C,0x07,0x07,0xC0,0x00,0x00,
0x00,0x00,0x00,0xEF,0x80,0x03,0x00,0x03,0x80,0x70,0x78,0x07,0x00,0x60,0x00,0x00,
0x00,0x00,0x07,0xF8,0x7F,0xFF,0xC0,0x0E,0x00,0x1C,0x00,0x07,0x00,0x00,0x00,0x00,
0x00,0x00,0x7F,0xFF,0xFF,0xFF,0x30,0x38,0x00,0x07,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0xFF,0xFF,0xFF,0xFF,0xFE,0x43,0xFF,0xFF,0xE0,0x00,0x00,0x00,0x00,0x00,
0x00,0x07,0x00,0x00,0x00,0x00,0x03,0x40,0x00,0x00,0x38,0x00,0x00,0x00,0x00,0x00,
0x00,0x1F,0xFF,0xFF,0xFF,0xFF,0xC0,0xE1,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,0x00,
0x00,0xF0,0x00,0x00,0x00,0x00,0x00,0x38,0x3F,0xFF,0xE0,0xE0,0x00,0x00,0x00,0x00,
0x03,0xBF,0xFF,0xFF,0xFF,0xFF,0x80,0x0E,0x7F,0xFF,0xFE,0x1E,0x00,0x00,0x00,0x00,
0x0E,0x00,0x00,0x00,0x00,0x00,0x01,0xFF,0x80,0x00,0x00,0x03,0xC0,0x00,0x00,0x00,
0x18,0x00,0x00,0x00,0x00,0x3F,0xFF,0x00,0xC1,0xFF,0xFF,0xFF,0x38,0x00,0x00,0x00,
0x10,0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x70,0x00,0x00,0x00,0x07,0x00,0x00,0x00,
0x00,0x7F,0xFE,0x00,0x00,0x00,0x00,0x00,0x0C,0x1F,0xFF,0xFF,0xFF,0xFF,0xFF,0xE0,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00

};
static const uint8_t PROGMEM Strong_16x16[] =
{0x10,0x10,0x28,0x48,0x84,0x02,0x7D,0x44,
0x44,0x44,0x54,0x24,0x04,0x04,0xF8,0x00,
0x20,0x20,0x20,0x24,0x24,0x25,0x24,0x24,
0x24,0x24,0x24,0x24,0x21,0x21,0x29,0x10};/*"创",0*/

#define OLED_RESET -1
Adafruit_SSD1306 display(OLED_RESET);

#define SCREEN_WIDTH  128
#define SCREEN_HEIGHT 64

#define BAR_X_OFFSET  0
#define BAR_Y_OFFSET  32
#define BAR_ZORE      22
#define BAR_MIN       -10
#define BAR_MAX       22

//#define WHITE    #0x07E0

int followers[SCREEN_WIDTH] = {0};
int followersIndex = 0;
bool runInit = false;
int followerTemp = 0;

ESP8266WiFiMulti WiFiMulti;
char s[100]="";
//修改: 把这里面的数字改成你自己的数字即可
char url[100] = "http://api.bilibili.com/x/relation/stat?vmid=21045676";
int follower = -1;

void setup() {
  Serial.begin(9600);
  // 等待串口可用
  while (!Serial) ;

  WiFi.mode(WIFI_STA);
  //修改: WIFI名称和密码, 注意名称只允许用英文或者英文符号
  WiFiMulti.addAP("TPLINK", "11223344");
  //修改: 如果无法正常显示, 把5,4颠倒位置即可(注意逗号为英文逗号)
  //ESP8266-12  D1(GPIO5)/D2(GPIO4) => SDA/SCL
  //ESP8266-01  Tx(GPIO1)/Rx(GPIO3) => SDA/SCL
  Wire.begin(5, 4);
  Wire.setClock(700000);
  display.begin(SSD1306_SWITCHCAPVCC, 0x3C);
  display.setTextSize(2);
  display.setTextColor(WHITE);
  display.clearDisplay();
  //display.drawBitmap(16,16,Strong_16x16,16,16,WHITE);
  display.drawBitmap(0, 0, LOGO_HJ, 128, 64, WHITE); 
//  display.fillScreen(WHITE);
  display.display();
  delay(5000); 
}

// the loop function runs over and over again forever
void loop() {
 flushOleddefault();
  requestUrl(url);
  delay(10000);
  
}

void requestUrl(char *url) {
  if ((WiFiMulti.run() == WL_CONNECTED)) {
    HTTPClient http;
    http.begin(url);
    int httpCode = http.GET();
    if (httpCode > 0) {
      if (httpCode == HTTP_CODE_OK) {
        String payload = http.getString();
        follower = parseJsonText(payload);
        sprintf(s, "%d", follower);
        Serial.print(followerTemp);
        Serial.print(",");
        Serial.println(follower);
        if (runInit) {
          followers[followersIndex] = follower - followerTemp;
          Serial.print("计算");
          Serial.println(follower - followerTemp);
          followerTemp = follower;
        } else {
          followerTemp = follower;
          Serial.print("初始化tmp=");
          Serial.println(followerTemp);
          followers[followersIndex] = 0;
          runInit = true;
        }
        followersIndex ++;
        flushOled(s);
      } else {
        Serial.println("Request ERROR");
      }
    } else {
      Serial.println("Request Url Failed");
    }
    http.end();
  } else {
    Serial.println("WiFi: NOT CONNECTED");
    flushOled("WiFi: NOT CONNECTED");
  }
}

int parseJsonText(String s) {
  StaticJsonDocument<300> jsonBuffer;
//  JsonObject& root = jsonBuffer.parseObject(s);
//  if (!root.success()) {
//    Serial.println("Parse Json Text Failed!");
//    return -1;
//  }
  auto error = deserializeJson(jsonBuffer, s);
  if (error) {
      Serial.print(F("deserializeJson() failed with code "));
      Serial.println(error.c_str());
      return -1;
  }
  follower = jsonBuffer["data"]["follower"];
  return follower;
}
void flushOleddefault() {
  display.clearDisplay();
  display.setCursor(0, 0);
  display.print("refresh");
  display.display();
}



void flushOled(char *s) {
  display.clearDisplay();
  display.drawBitmap(0, 0, LOGO_CH[0], 8, 16, WHITE);
  display.drawBitmap(8, 0, LOGO_CH[1], 8, 16, WHITE);
  display.drawBitmap(16, 0, LOGO_CH[2], 16, 16, WHITE);
  display.drawBitmap(0, 17, LOGO_CH[3], 16, 16, WHITE);
  display.drawBitmap(16, 17, LOGO_CH[4], 16, 16, WHITE);
  display.drawBitmap(32,17, LOGO_CH[5], 16, 16, WHITE);
  display.drawBitmap(32, 0, LOGO_CH[6], 16, 16, WHITE);
  display.drawBitmap(48, 0, LOGO_CH[7], 16, 16, WHITE);
  display.drawBitmap(64, 0, LOGO_CH[8], 16, 16, WHITE);
//  display.drawBitmap(80, 0, LOGO_CH[9], 16, 16, WHITE);
//  display.drawBitmap(96, 0, LOGO_CH[10], 16, 16, WHITE);
//  display.drawBitmap(112, 0, LOGO_CH[11], 16, 16, WHITE);
  display.setCursor(112, 0);
  display.setCursor(48, 17);  
  display.print(s);
  drawBar();
  display.display();
}

void drawBar() {
  for(int i = 0; i < SCREEN_WIDTH; i ++) {
    Serial.print(followers[i]);
    Serial.print(",");
  }
  Serial.println("+");
  int index = 0;
  for(int i = 0;i < SCREEN_WIDTH; i ++) {
    display.drawPixel(i, BAR_Y_OFFSET + BAR_ZORE, WHITE);
    //计算当前的索引序号
    index = (i + followersIndex) % SCREEN_WIDTH;
    if (followers[index] > BAR_MAX) {
      display.drawLine(i, BAR_Y_OFFSET + BAR_ZORE, i, BAR_Y_OFFSET + BAR_ZORE - BAR_MAX, WHITE);
    } else if (followers[index] < BAR_MIN) {
      display.drawLine(i, BAR_Y_OFFSET + BAR_ZORE, i, BAR_Y_OFFSET + BAR_ZORE - BAR_MIN, WHITE);
    } else {
      display.drawLine(i, BAR_Y_OFFSET + BAR_ZORE, i, BAR_Y_OFFSET + BAR_ZORE - followers[index], WHITE);
    }
  }
}
